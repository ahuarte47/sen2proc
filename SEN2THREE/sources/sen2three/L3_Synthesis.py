#!/usr/bin/env pythonfrom numpy import *import timefrom datetime import datetimefrom lxml import objectifyfrom L3_Library import stdoutWrite, showImagefrom L3_XmlParser import L3_XmlParserfrom L3_Display import L3_Displayfrom scipy.stats import itemfreqfrom scipy import ndimagefrom scipy.ndimage.morphology import *class L3_Synthesis(object):    ''' Performs the spatio temporal algorithms.        :param config: the config object for the current tile (via __init__).        :type config: a reference to the L3_Config object.    '''    def __init__(self, config):        self._config = config        self._product = None        self._tables = None        self._badPixelMask2A = None        self._goodPixelMask2A = None        self._badPixelMask03 = None        self._goodPixelMask03 = None        self._scl2A = None        self._aot2A = None        self._sza2A = None        self._scl03 = None        self._aot03 = None        self._sza03 = None        self._isBetterScene = False        self._bestSZA = 0.0        self._bestAOT = 1.0        self._noData = self.config.classifier['NO_DATA']        self._saturatedDefective = self.config.classifier['SATURATED_DEFECTIVE']        self._darkFeatures = self.config.classifier['DARK_FEATURES']        self._notVegetated = self.config.classifier['NOT_VEGETATED']        self._snowIce = self.config.classifier['SNOW_ICE']        self._vegetation = self.config.classifier['VEGETATION']        self._water = self.config.classifier['WATER']        self._unclassified = self.config.classifier['UNCLASSIFIED']        self._medProbaClouds = self.config.classifier['MEDIUM_PROBA_CLOUDS']        self._highProbaClouds = self.config.classifier['HIGH_PROBA_CLOUDS']        self._thinCirrus = self.config.classifier['THIN_CIRRUS']        self._cloudShadows = self.config.classifier['CLOUD_SHADOWS']        if self._config.displayData:            self._display = L3_Display(self._config)        else:            self._display = None        self.config.logger.debug('Module L3_STP initialized')        self._processingStatus = True        def get_config(self):        return self._config    def get_product(self):        return self._product    def get_tables(self):        return self._tables    def set_config(self, value):        self._config = value    def set_product(self, value):        self._product = value    def set_tables(self, value):        self._tables = value    def del_config(self):        del self._config    def del_product(self):        del self._product    def del_tables(self):        del self._tables    config = property(get_config, set_config, del_config)    product = property(get_product, set_product, del_product)    tables = property(get_tables, set_tables, del_tables)    def setPixelMasks(self):        ''' Sets the pixel masks according to following algorithm:            1. initialize good and bad pixels;            2. create mosaic map, if not exist, else read from L3_Tables;            3. update mosaic map and scene classification map according to selected algorithm:                if self.config.algorithm == 'MOST_RECENT':                    previous classification map will always be replaced with good pixels of recent classification map                    if the time stamp of the recent tile is more actual than of any scene in the past;                else if self.config.algorithm == 'TEMP_HOMOGENEITY':                    previous classification map will only be replaced if sum of current good pixels                    is better than sum of good pixels of the best classification map in the past;                else if self.config.algorithm == 'RADIOMETRIC_QUALITY':                    previous classification map will be replaced if either:                    - the average of the current AOT is lower or                    - the average of the current Solar Zenith Angle                    is higher than the equivalent parameter of the best classification map in the past;                else if self.config.algorithm == 'AVERAGE':                    images are an average of the current good pixels and the                    good pixels of all previous scenes. Mosaic map is the per pixel sum                    of all good pixels in the past and is used for calculating the average;            4. update good and bad pixel masks;        '''        saturatedDefective = self._saturatedDefective        notVegetated = self._notVegetated        vegetation = self._vegetation        water = self._water        noData = self._noData        cirrus = self._thinCirrus        darkFeatures = self._darkFeatures        cloudShadows = self._cloudShadows        unclassified = self._unclassified        medProbaClouds = self._medProbaClouds        highProbaClouds = self._highProbaClouds        snowIce = self._snowIce        self._isBetterScene = False        T_CLOUD_LP = 0        T_CLOUD_MP = 0.2        T_CLOUD_HP = 0.8        ntProcessed = self.config.getNrTilesProcessed()        self.config.timestamp('L3_Process: nr processed tiles: %d' % ntProcessed)        ntProcessed += 1        scl2A = self.tables.getBand('L2A', self.tables.SCL)        scl03 = self.tables.getBand('L3', self.tables.SCL)        # cld2A = self.tables.getBand('L2A', self.tables.CLD)        # cld03 = self.tables.getBand('L3', self.tables.CLD)        BPM2A = ones_like(scl2A)        BPM03 = ones_like(scl03)        BPM2A[(scl2A == notVegetated) | (scl2A == vegetation) | (scl2A == water)] = 0        BPM03[(scl03 == notVegetated) | (scl03 == vegetation) | (scl03 == water)] = 0        if self.config.cirrusRemoval == False:            BPM2A[scl2A == cirrus] = 0            BPM03[scl03 == cirrus] = 0        if self.config.shadowRemoval == False:            BPM2A[(scl2A == darkFeatures) | (scl2A == cloudShadows)] = 0            BPM03[(scl03 == darkFeatures) | (scl03 == cloudShadows)] = 0        if self.config.snowRemoval == False:            BPM2A[scl2A == snowIce] = 0            BPM03[scl03 == snowIce] = 0        # Create a hierachy of cloud probability in scene class and replace, if less:        BPM2A[(scl2A == cirrus) & (BPM03 == 1)] = 0        BPM2A[(scl2A == medProbaClouds) & (scl03 == highProbaClouds)] = 0        BPM2A[(scl2A == unclassified) & ((scl03 == medProbaClouds) | (scl03 == highProbaClouds))] = 0        BPM2A[(scl2A == darkFeatures) & ((scl03 == medProbaClouds) | (scl03 == highProbaClouds))] = 0        BPM2A[(scl2A == snowIce) & ((scl03 == medProbaClouds) | (scl03 == highProbaClouds))] = 0        BPM03[(scl03 == cirrus) & (BPM2A == 1)] = 0        BPM03[(scl03 == medProbaClouds) & (scl2A == highProbaClouds)] = 0        BPM03[(scl03 == unclassified) & ((scl2A == medProbaClouds) | (scl2A == highProbaClouds))] = 0        BPM03[(scl03 == darkFeatures) & ((scl2A == medProbaClouds) | (scl2A == highProbaClouds))] = 0        BPM03[(scl03 == snowIce) & ((scl2A == medProbaClouds) | (scl2A == highProbaClouds))] = 0        # If 'better' features already exist, keep these:        scl2A[(scl03 == cirrus) & (BPM2A == 1)] = cirrus        scl2A[(scl03 == medProbaClouds) & (scl2A == highProbaClouds)] = medProbaClouds        scl2A[(scl03 == unclassified) & ((scl2A == medProbaClouds) | (scl2A == highProbaClouds))] = unclassified        scl2A[(scl03 == darkFeatures) & ((scl2A == medProbaClouds) | (scl2A == highProbaClouds))] = darkFeatures        scl2A[(scl03 == snowIce) & ((scl2A == medProbaClouds) | (scl2A == highProbaClouds))] = snowIce        # Median Filter:        mf = self.config.medianFilter        if mf > 0:            # binary dilation first, to increase shape:            struct = generate_binary_structure(2, 1)            BPM2A = ndimage.binary_dilation(BPM2A, struct).astype(BPM2A.dtype)            BPM03 = ndimage.binary_dilation(BPM03, struct).astype(BPM03.dtype)            # now the median filter:            BPM2A = ndimage.filters.median_filter(BPM2A, (mf,mf))            BPM03 = ndimage.filters.median_filter(BPM03, (mf,mf))        GPM2A = 1 - BPM2A        GPM03 = 1 - BPM03        # Create mosaic map if not exist, else read from table:        if self.tables.testBand('L3', self.tables.MSC) == False:            mosaicMap = zeros_like(GPM03)            mosaicMap[GPM03 == 1] = 1            self.tables.setBand('L3', self.tables.MSC, mosaicMap.astype(uint8))            self.updateL3MosaicQI(first=True)            if self._display is not None:                self._display.displayData(self.tables)        else:            mosaicMap = self.tables.getBand('L3', self.tables.MSC)        if self.config.algorithm == 'MOST_RECENT':            # previous scene will always be replaced by good pixels of recent scene            # if the time stamp of the recent tile is more actual than of any scene in the past:            if self.isMoreRecent():                scl03[GPM2A == 1] = scl2A[GPM2A == 1]                mosaicMap[GPM2A == 1] = ntProcessed            mosaicMap[(GPM2A == 1) & (GPM03 == 0)] = ntProcessed                           elif self.config.algorithm == 'TEMP_HOMOGENEITY':            # previous scene will only be replaced if sum of current good pixels            # is better than sum of good pixels of the best scene in the past:            GP2Asum = float32(count_nonzero(GPM2A[GPM2A == 1]))            mmif = itemfreq(mosaicMap[GPM03 == 1])            bestScenePast = float32((mmif[:,1]).max())            if(GP2Asum / bestScenePast) > 1.0:                self._isBetterScene = True                scl03[GPM2A == 1] = scl2A[GPM2A == 1]                mosaicMap[GPM2A == 1] = ntProcessed            mosaicMap[(GPM2A == 1) & (GPM03 == 0)] = ntProcessed        elif self.config.algorithm == 'RADIOMETRIC_QUALITY':            # previous scene will be replaced if either:            # - the average of the current AOT or            # - the average of the current Solar Zenith Angle            # is better than the equivalent parameter of the best scene in the past:            if self.config.radiometricPreference == 'SOLAR_ZENITH':                if self.szaIsHigher():                    scl03[(GPM2A == 1)] = scl2A[(GPM2A == 1)]                    mosaicMap[GPM2A == 1] = ntProcessed                    self._isBetterScene = True                mosaicMap[(GPM2A == 1) & (GPM03 == 0)] = ntProcessed            else: # AOT:                if self.aotIsLower(GPM2A):                    scl03[(GPM2A == 1)] = scl2A[(GPM2A == 1)]                    mosaicMap[GPM2A == 1] = ntProcessed                    self._isBetterScene = True                mosaicMap[(GPM2A == 1) & (GPM03 == 0)] = ntProcessed        elif self.config.algorithm == 'AVERAGE':            # images are an average of the current good pixels and the            # good pixels of all previous scenes. Mosaic map is the per pixel sum            # of all good pixels in the past and is used for calculating the average:            mosaicMap[GPM2A == 1] = mosaicMap[GPM2A == 1] + 1        # fill always the bad pixels with good ones:        scl03[(GPM2A == 1) & (GPM03 == 0)] = scl2A[(GPM2A == 1) & (GPM03 == 0)]        # cld03[(cld2A < cld03) & (scl2A != self._noData)] = \        #     cld2A[(cld2A < cld03) & (scl2A != self._noData)]        # self.tables.setBand('L3', self.tables.CLD, cld03)        self.tables.setBand('L3', self.tables.SCL, scl03.astype(uint8))        self.tables.setBand('L3', self.tables.MSC, mosaicMap.astype(uint8))        self._goodPixelMask2A = GPM2A        self._goodPixelMask03 = GPM03        self._badPixelMask2A  = BPM2A        self._badPixelMask03  = BPM03        self._scl2A = scl2A        self._scl03 = scl03        return    def isMoreRecent(self):        ''' Check if current timestamp is more recent than any timestamp of the past:            :return: true if more recent            :rtype: bool        '''        key = 'DATE_TIME'        timestamp = self.config.L2A_UP_ID        prdMinTimeS = timestamp[45:60]        prdMinTime = time.mktime(datetime.strptime(prdMinTimeS,'%Y%m%dT%H%M%S').timetuple())        mostRecentPast = self.product.getTableVal(key)        if prdMinTime > mostRecentPast:  # more recent is better!            self.product.setTableVal(key, prdMinTime)            self._isBetterScene = True        return self._isBetterScene    def szaIsHigher(self):        ''' Check if current Solar Zenith Angle is higher than any SZA of the past:            :return: true if higher            :rtype: bool        '''        key = 'SZA_MEAN'        sza2A = self.readSolarZenithAngle('T2A')        bestSzaPast = self.product.getTableVal(key)        if sza2A > bestSzaPast:  # higher is better!            self.product.setTableVal(key, sza2A)            self._isBetterScene = True        return self._isBetterScene    def aotIsLower(self, GPM2A):        ''' Check if current Aerosol Optical Thickness is lower than any AOT of the past:            :return: true if lower            :rtype: bool        '''        key = 'AOT_MEAN'        aotArr2A = self.tables.getBand('L2A', self.tables.AOT)        aotMean2A = (aotArr2A[GPM2A == 1]).mean() * 0.001        bestAotPast = self.product.getTableVal(key)        if aotMean2A < bestAotPast:  # lower is better!            self.product.setTableVal(key, aotMean2A)            self._isBetterScene = True        return self._isBetterScene    def replaceBadPixels(self, bandIndex):        ''' Replaces the bad pixels by good ones, according to following algorithm:            1. get the bands from previous and current scene;            2. get the good pixel masks from function L3_Synthesis.setPixelMasks;            3. set the bad pixels to saturated / defective;            4. update bands according to selected algorithm:                if self.config.algorithm == 'MOST_RECENT':                    previous pixels will always be replaced with good pixels of recent scene                    if the time stamp of the recent tile is more actual than of any scene in the past;                else if self.config.algorithm == 'TEMP_HOMOGENEITY':                    previous pixels will only be replaced if sum of current good pixels                    is better than sum of good pixels of the best scene in the past;                else if self.config.algorithm == 'RADIOMETRIC_QUALITY':                    previous pixels will be replaced if either:                    - the average of the current AOT is lower or                    - the average of the current Solar Zenith Angle                    is higher than the equivalent parameter of the best classification map in the past;                else if self.config.algorithm == 'AVERAGE':                    images are an average of the current good pixels and the                    good pixels of all previous scenes. Mosaic map is the per pixel sum                    of all good pixels in the past and is used for calculating the average;            :param bandIndex: the band index.            :type bandIndex: unsigned int        '''        BL2A = self.tables.getBand('L2A', bandIndex)        BL03 = self.tables.getBand('L3', bandIndex)        GPM2A = self._goodPixelMask2A        GPM03 = self._goodPixelMask03        # fill always the bad pixels with good ones:        BL03[((GPM2A-GPM03) == 1)] = BL2A[((GPM2A-GPM03) == 1)]        if self.config.algorithm == 'MOST_RECENT':            # previous scene will always be replaced by good pixels of recent scene            # if the time stamp of the recent tile is more actual than of any scene in the past:            if self._isBetterScene:                BL03[(GPM2A == 1)] = BL2A[(GPM2A == 1)]        elif self.config.algorithm == 'TEMP_HOMOGENEITY':            # previous scene will only be replaced if sum of current good pixels            # is better than sum of good pixels of the best scene in the past:            if self._isBetterScene:                BL03[(GPM2A == 1)] = BL2A[(GPM2A == 1)]        elif self.config.algorithm == 'RADIOMETRIC_QUALITY':            # previous scene will be replaced if either:            # - the average of the current AOT or            # - the average of the current Solar Zenith Angle            # is better than the equivalent parameter of the best scene in the past:            if self._isBetterScene:                BL03[(GPM2A == 1)] = BL2A[(GPM2A == 1)]                elif self.config.algorithm == 'AVERAGE':            # new scene is an average of the current good pixels and the            # good pixels of all previous scenes:            mosaicMap = self.tables.getBand('L3', self.tables.MSC)            BL03[GPM2A == 1] = ((BL03[GPM2A == 1] * (mosaicMap[GPM2A == 1] - 1) + \                                BL2A[GPM2A == 1])) / mosaicMap[GPM2A == 1]        self.tables.setBand('L3', bandIndex, BL03)        return            def updateL3MosaicQI(self, first=False):        ''' Update the L3 Mosaic Map after each new cycle.           :param first: true if first tile.           :type first: bool        '''        # add mosaic values in list:        tilesProcessedCount = self.config.getNrTilesProcessed()        if first:            xp = L3_XmlParser(self.config, 'T03')            aotArr = self.tables.getBand('L3', self.tables.AOT)            szaMean = self.readSolarZenithAngle('T03')            TILE_ID = self.config.TILE_ID_2A            PRODUCT_ID = self.config.L2A_UP_ID_first        else:            xp = L3_XmlParser(self.config, 'T2A')            aotArr = self.tables.getBand('L2A', self.tables.AOT)            szaMean = self.readSolarZenithAngle('T2A')            TILE_ID = xp.getTree('General_Info', 'TILE_ID_2A')            if TILE_ID == False:                TILE_ID = xp.getTree('General_Info', 'TILE_ID')            PRODUCT_ID = self.config.L2A_UP_ID            TILE_ID = TILE_ID.text        mosaic = self.tables.getBand('L3', self.tables.MSC)        scenec = self.tables.getBand('L3', self.tables.SCL)        validData = [scenec != self._noData]        try:            aotMean = aotArr[(validData)].mean() * 0.001        except:            aotMean = 0        validPixelCount = float32(count_nonzero(scenec))        sensingTime = xp.getTree('General_Info', 'SENSING_TIME')        sensingTime = sensingTime.text        try:            freqMTF = itemfreq(mosaic[validData])[:,1]        except:            freqMTF = 0        percMTF = (float32(freqMTF) / validPixelCount) * 100.0        idxMoif = itemfreq(mosaic)[:, 0]        nClasses = idxMoif.max()        xMoif = arange(0, nClasses+1)        yMoif = zeros(nClasses+1, dtype=int)        yMoif[idxMoif] = itemfreq(mosaic)[:, 1]        yMoifCount = float32(yMoif.sum())        yMoifPerc = yMoif.astype(float32) / yMoifCount * 100.0        mosaicContent = objectify.Element('Mosaic_Content')        mosaicContent.attrib['tileNumber'] = str(tilesProcessedCount)        mosaicContent.append(objectify.Element('PRODUCT_ID'))        mosaicContent.append(objectify.Element('TILE_ID'))        mosaicContent.append(objectify.Element('TILE_PIXEL_COUNT'))        mosaicContent.append(objectify.Element('TILE_PIXEL_PERCENTAGE'))        mosaicContent.append(objectify.Element('TILE_DATE_TIME'))        mosaicContent.append(objectify.Element('TILE_AOT_MEAN'))        mosaicContent.append(objectify.Element('TILE_SZA_MEAN'))        mosaicContent.PRODUCT_ID = PRODUCT_ID        mosaicContent.TILE_ID = TILE_ID        mosaicContent.TILE_PIXEL_COUNT = '0'        mosaicContent.TILE_PIXEL_PERCENTAGE = '0.0'        mosaicContent.TILE_DATE_TIME = sensingTime        mosaicContent.TILE_AOT_MEAN = aotMean        mosaicContent.TILE_SZA_MEAN = szaMean        mosaicContent.TILE_SZA_MEAN.attrib['unit'] = 'deg'        xp = L3_XmlParser(self.config, 'T03')        mqi = xp.getTree('Quality_Indicators_Info', 'Mosaic_QI')        mqiLen = len(mqi)        for i in range(mqiLen):            if int(mqi[i].attrib['resolution']) == self.config.resolution:                mqi[i].append(mosaicContent)                mccLen = len(mqi[i].Mosaic_Content)                for j in range(mccLen):                    try:                        mqi[i].Mosaic_Content[j].attrib['tileNumber'] = str(xMoif[j+1])                        mqi[i].Mosaic_Content[j].TILE_PIXEL_COUNT = str(yMoif[j+1])                        mqi[i].Mosaic_Content[j].TILE_PIXEL_PERCENTAGE = str(yMoifPerc[j+1])                    except:                        scenec = self.tables.getBand('L3', self.tables.SCL)                        totalPixelCount = size(scenec)                        dataPixelCount = count_nonzero(scenec)                        dataPixelPercentage = float32(dataPixelCount) / float32(totalPixelCount) * 100.0                        mqi[i].Mosaic_Content[j].attrib['tileNumber'] = str(0)                        mqi[i].Mosaic_Content[j].TILE_PIXEL_COUNT = str(dataPixelCount)                        mqi[i].Mosaic_Content[j].TILE_PIXEL_PERCENTAGE = str(dataPixelPercentage)        xp.export()        return True    def updateL3ClassificationQI(self):        ''' Update the L3 classification QI after each new cycle        '''        scenec = self.tables.getBand('L3', self.tables.SCL)        validData = [scenec != self._noData]        mosaic = self.tables.getBand('L3', self.tables.MSC)        totalPixelCount = size(scenec)        dataPixelCount = count_nonzero(scenec)        dataPixelPercentage = float32(dataPixelCount) / float32(totalPixelCount) * 100.0        backgroundPixelCount = totalPixelCount - dataPixelCount        backgroundPixelPercentage = float32(100.0 - dataPixelPercentage)        goodPixelCount = count_nonzero(mosaic)        goodPixelPercentage = float32(goodPixelCount) / float32(dataPixelCount) * 100.0        badPixelCount = size(mosaic) - goodPixelCount - backgroundPixelCount        badPixelPercentage = float32(badPixelCount) / float32(dataPixelCount) * 100.0        freqSCF = zeros([12], dtype=uint32)        idxSCF = itemfreq(scenec[validData])[:,0]        freqSCF[idxSCF] = itemfreq(scenec[validData])[:,1]                           percSCF = freqSCF.astype(float32) / float32(dataPixelCount) * 100.0        classificationQI = objectify.Element('Classification_QI')        classificationQI.attrib['resolution'] = str(self.config.resolution)        classificationQI.append(objectify.Element('TOTAL_PIXEL_COUNT'))        classificationQI.append(objectify.Element('DATA_PIXEL_COUNT'))        classificationQI.append(objectify.Element('DATA_PIXEL_PERCENTAGE'))        classificationQI.append(objectify.Element('NODATA_PIXEL_COUNT'))        classificationQI.append(objectify.Element('NODATA_PIXEL_PERCENTAGE'))        classificationQI.append(objectify.Element('GOOD_PIXEL_COUNT'))        classificationQI.append(objectify.Element('GOOD_PIXEL_PERCENTAGE'))        classificationQI.append(objectify.Element('BAD_PIXEL_COUNT'))        classificationQI.append(objectify.Element('BAD_PIXEL_PERCENTAGE'))        classificationQI.append(objectify.Element('SATURATED_DEFECTIVE_PIXEL_COUNT'))        classificationQI.append(objectify.Element('SATURATED_DEFECTIVE_PIXEL_PERCENTAGE'))        classificationQI.append(objectify.Element('DARK_FEATURES_COUNT'))        classificationQI.append(objectify.Element('DARK_FEATURES_PERCENTAGE'))        classificationQI.append(objectify.Element('CLOUD_SHADOWS_COUNT'))        classificationQI.append(objectify.Element('CLOUD_SHADOWS_PERCENTAGE'))        classificationQI.append(objectify.Element('VEGETATION_COUNT'))        classificationQI.append(objectify.Element('VEGETATION_PERCENTAGE'))        classificationQI.append(objectify.Element('NOT_VEGETATED_COUNT'))        classificationQI.append(objectify.Element('NOT_VEGETATED_PERCENTAGE'))        classificationQI.append(objectify.Element('WATER_COUNT'))        classificationQI.append(objectify.Element('WATER_PERCENTAGE'))        classificationQI.append(objectify.Element('UNCLASSIFIED_COUNT'))        classificationQI.append(objectify.Element('UNCLASSIFIED_PERCENTAGE'))        classificationQI.append(objectify.Element('MEDIUM_PROBA_CLOUDS_COUNT'))        classificationQI.append(objectify.Element('MEDIUM_PROBA_CLOUDS_PERCENTAGE'))        classificationQI.append(objectify.Element('HIGH_PROBA_CLOUDS_COUNT'))        classificationQI.append(objectify.Element('HIGH_PROBA_CLOUDS_PERCENTAGE'))        classificationQI.append(objectify.Element('THIN_CIRRUS_COUNT'))        classificationQI.append(objectify.Element('THIN_CIRRUS_PERCENTAGE'))        classificationQI.append(objectify.Element('SNOW_ICE_COUNT'))        classificationQI.append(objectify.Element('SNOW_ICE_PERCENTAGE'))        classificationQI.TOTAL_PIXEL_COUNT = totalPixelCount        classificationQI.DATA_PIXEL_COUNT = dataPixelCount        classificationQI.DATA_PIXEL_PERCENTAGE = dataPixelPercentage        classificationQI.NODATA_PIXEL_COUNT = backgroundPixelCount        classificationQI.NODATA_PIXEL_PERCENTAGE = backgroundPixelPercentage        classificationQI.GOOD_PIXEL_COUNT = goodPixelCount        classificationQI.GOOD_PIXEL_PERCENTAGE = goodPixelPercentage        classificationQI.BAD_PIXEL_COUNT = badPixelCount        classificationQI.BAD_PIXEL_PERCENTAGE = badPixelPercentage        classificationQI.SATURATED_DEFECTIVE_PIXEL_COUNT = freqSCF[self._saturatedDefective]        classificationQI.SATURATED_DEFECTIVE_PIXEL_PERCENTAGE = percSCF[self._saturatedDefective]        classificationQI.DARK_FEATURES_COUNT = freqSCF[self._darkFeatures]        classificationQI.DARK_FEATURES_PERCENTAGE = percSCF[self._darkFeatures]        classificationQI.CLOUD_SHADOWS_COUNT = freqSCF[self._cloudShadows]        classificationQI.CLOUD_SHADOWS_PERCENTAGE = percSCF[self._cloudShadows]        classificationQI.VEGETATION_COUNT = freqSCF[self._vegetation]        classificationQI.VEGETATION_PERCENTAGE = percSCF[self._vegetation]        classificationQI.NOT_VEGETATED_COUNT = freqSCF[self._notVegetated]        classificationQI.NOT_VEGETATED_PERCENTAGE = percSCF[self._notVegetated]        classificationQI.WATER_COUNT = freqSCF[self._water]        classificationQI.WATER_PERCENTAGE = percSCF[self._water]        classificationQI.UNCLASSIFIED_COUNT = freqSCF[self._unclassified]        classificationQI.UNCLASSIFIED_PERCENTAGE = percSCF[self._unclassified]        classificationQI.MEDIUM_PROBA_CLOUDS_COUNT = freqSCF[self._medProbaClouds]        classificationQI.MEDIUM_PROBA_CLOUDS_PERCENTAGE = percSCF[self._medProbaClouds]        classificationQI.HIGH_PROBA_CLOUDS_COUNT = freqSCF[self._highProbaClouds]        classificationQI.HIGH_PROBA_CLOUDS_PERCENTAGE = percSCF[self._highProbaClouds]        classificationQI.THIN_CIRRUS_COUNT = freqSCF[self._thinCirrus]        classificationQI.THIN_CIRRUS_PERCENTAGE = percSCF[self._thinCirrus]        classificationQI.SNOW_ICE_COUNT = freqSCF[self._snowIce]        classificationQI.SNOW_ICE_PERCENTAGE = percSCF[self._snowIce]        xp = L3_XmlParser(self.config, 'T03')        l3qi = xp.getTree('Quality_Indicators_Info', 'Classification_QI')        l3qiLen = len(l3qi)        for i in range(l3qiLen):            if int(l3qi[i].attrib['resolution']) == self.config.resolution:                l3qi[i].clear()                l3qi[i] = classificationQI                xp.export()                self.product.updateTableRow(classificationQI)                break        return True    def readSolarZenithAngle(self, productStr):        ''' Helper class for reading the mean solar zenith angle from metadata            :param productStr: [L2A | L3].            :type productStr: str            :return: solar zenith angle            :rtype: unsigned float        '''        xp = L3_XmlParser(self.config, productStr)        ang = xp.getTree('Geometric_Info', 'Tile_Angles')        sza = float32(ang.Mean_Sun_Angle.ZENITH_ANGLE.text)        sza = absolute(sza)        if sza > 70.0: sza = 70.0        return sza    def preProcessing(self):        ''' Performs the pre processing, updates the pixel mask        '''        self.config.timestamp('L3_Synthesis: pre processing')        self.setPixelMasks()        if self._display is not None:            self._display.displayData(self.tables)        return    def forwardProcessing(self):        ''' This is the default processing routine: it removes clouds and dark features            from an input image. Calls the routine replaceBadPixels and updates the statistic        '''        for i in self.tables.bandIndex:            self.replaceBadPixels(i)        self.updateL3ClassificationQI()        self.updateL3MosaicQI()        if self._display is not None:            self._display.displayData(self.tables)        return    def postProcessing(self):        ''' Performs a validation of the metadada and prepares a statistics display, if activated        '''        self.product.postProcessing()        self.config.timestamp('L3_Synthesis: post processing')        # Output product shall be aligned to latest product version, currently 14.5:        self.config.productVersion = '14.5'        self.config.setSchemes()        # validate the meta data:        xp = L3_XmlParser(self.config, 'UP03')        xp.validate()        xp = L3_XmlParser(self.config, 'T03')        xp.validate()        xp = L3_XmlParser(self.config, 'DS03')        xp.validate()        return        def __exit__(self):        sys.exit(-1)    def __del__(self):        self.config.logger.info('Module L3_Synthesis deleted')            def process(self, tables):        ''' Triggers pre -, processing and post processing        '''        ts = time.time()        self.tables = tables        self.product = tables.product        self.config = tables.product.config        self.preProcessing()        self.forwardProcessing()        tDelta = time.time() - ts        self.config.logger.info('Procedure L3_Synthesis: overall time [s]: %0.3f' % tDelta)        if(self.config.loglevel == 'DEBUG'):            stdoutWrite('Procedure L3_Synthesis: overall time[s]: %0.3f\n' % tDelta)        return True